using System;
using System.Runtime.CompilerServices;
using CodeHelpers.Diagnostics;

namespace EchoRenderer.Common.Memory;

public readonly struct View<T>
{
	//REMOVE COMMENT: invokes your own implementations to reduce duplicating code
	public View(T[] array, int start = 0) : this(array, start, array.Length - start) { }

	public View(T[] array, int start, int count)
	{
		Assert.IsNotNull(array); //REMOVE COMMENT: also ensure array should never be null
		Assert.IsTrue(start < array.Length);
		Assert.IsFalse(count + start > array.Length);

		this.array = array;
		this.start = start;
		Length = count;
	}

	//REMOVE COMMENT: ref getters also allows set so we dont need setters with this modification
	public ref T this[int index] => ref array[AssertShift(index)];

	// REMOVE COMMENT: with the slice methods, this indexer is generated by the compiler
	// public View<T> this[Range range] => Slice(range.Start.Value, range.End.Value - range.Start.Value);

	// REMOVE COMMENT: also the indexer with the Index struct is generated because we have a regular int indexer and Length

	public int Length { get; }

	public bool IsEmpty => Length == 0; //REMOVE COMMENT: removed array check since it is not necessary

	readonly T[] array;
	readonly int start;

	public void Clear() => throw new NotImplementedException();

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public View<T> Slice(int offset) => Slice(offset, Length - offset);

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public View<T> Slice(int offset, int length) => new(array, AssertShift(offset), length);

	//REMOVE COMMENT: added overloads to allow slicing
	public Span<T> AsSpan() => this;
	public Span<T> AsSpan(int offset) => this[offset..];
	public Span<T> AsSpan(int offset, int length) => Slice(offset, length);

	/// <summary>
	///     Asserts and Shifts the view array index to the original array index
	///     if the <paramref name="index" /> is less than <see cref="Length" />
	/// </summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	int AssertShift(int index)
	{
		Assert.IsTrue(index < Length);
		return start + index;
	}

	//REMOVE COMMENT: static members should (is nice to) be placed at the end of the class
	public static implicit operator ReadOnlyView<T>(View<T> view) => new(view.array, view.start, view.Length);
	public static implicit operator ReadOnlySpan<T>(View<T> view) => new(view.array, view.start, view.Length);
	public static implicit operator Span<T>(View<T> view) => new(view.array, view.start, view.Length);
}
public static class ViewExtensions
{
	//REMOVE COMMENT: added overloads to allow for slicing and converting with the same method call
	public static View<T> AsView<T>(this T[] array, int start = 0) => new(array, start);
	public static View<T> AsView<T>(this T[] array, int start, int length) => new(array, start, length);
}